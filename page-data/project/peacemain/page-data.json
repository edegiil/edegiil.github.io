{"componentChunkName":"component---src-templates-project-js","path":"/project/peacemain","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://drive.google.com/uc?export=download&#x26;id=16YIEYZh4toCHhMTsjSTaLU_UXjMWhHyu\" alt=\"피스메인\"></p>\n<h3>프로젝트에 대한 이야기</h3>\n<p>갑자기 삘받아 웹 개발 스터디를 모집해보고 싶었다. 그냥 모집하는 거 보다는 웹을 직접 만들어서 그걸로 사람을 모집한다면 좀 더 웹 개발 스터디의 차별성을 강화하고, 정체성을 살릴 수 있을 것 같았다.\n하루만에 만들 수 있을까 했는데, 역시 기획이 없으니 조금 까다로웠다. 그렇지만 어떻게 하루만에 모두 완성이 된게 만족스럽다.</p>\n<p>새로운 기술도 사용해서 추가를 해보려고 했는데, 이번엔 타입스크립트를 적용해보았다.</p>\n<p>프론트엔드에 바로 파이어베이스 연결해서 할 수도 있었지만, 나중에 다른 기능들을 추가하기 위해서 간단하게 Express로 API 서버를 만들어서 붙였다.</p>\n<h3>개발한 기능은?</h3>\n<ul>\n<li>동아리 모집 소개페이지</li>\n<li>동아리 신청서 기능</li>\n</ul>\n<h3>사용한 기술 스택</h3>\n<ul>\n<li>React: 웹은 리액트</li>\n<li>Typescript: CRA에 타입스크립트 설정이 있어서, 그걸로 진행했다. npm으로 모듈의 타입도 다운받았어야 했는데, 확실히 Flow보다는 사용하기 쉬운 것 같다. 타입 체킹이 되는 것은 크게 효용을 못느꼈지만 어떤 parameter를 안 적었는지와 같은 오류를 찾아주는 건 확실히 자바스크립트보다 좋았다.</li>\n<li>Styled-Component: 두번째로 사용해보는데, 좀 더 모듈화를 진행해보려고 했는데, 시간 때문에 못해봤다. 다음 프로젝트때는 어떻게 모듈화를 할 수 있을지 고민해서 해봐야겠다.</li>\n</ul>\n<h3>프로젝트하면서 겪은 이슈와 해결방법</h3>\n<p>하루짜리 간단한 프로젝트라 크게 문제는 없었다. 다만 타입스크립트를 적용할 때에 React.FC가 Functional Component의 타입인줄 알고 아래와 같이 했었는데,</p>\n<pre><code class=\"language-tsx\">function Main(): React.FC {\n  // ...\n}\n</code></pre>\n<p>이상하게 잘 안됐다. <code>React.FC</code>를 사용하지 않고 그냥 컴포넌트에 타입을 적지말라는 글도 있었는데, 타입적으라는 경고창이 거슬려서 찾던 중 <code>React.ReactElement</code>를 적용했는데, 잘 되더라.\n<code>React.ReactNode</code>와 <code>React.ReactElement</code>의 차이점에 대해서 이 기회에 알게 되었다.</p>\n<p>모집이 끝나고 면접 일정 등록하는 페이지를 만들어야 했는데, 보안적인 문제가 생각났다. 코드도 퍼블릭 스토리지로 만들어서 모두 공개했는데, 누가 혹시나 악의적인 마음으로 웹서비스를 공격이라도 하면 어떻게 될까? 생각이 들었다.</p>\n<p>크게 발생할 수 있을 것 같은 보안문제를 생각해보니,</p>\n<ul>\n<li>HTTP 요청을 하는 API의 엔드포인트가 드러나서 다른 방식으로 요청을 하는 경우</li>\n<li>HTTP 요청시에 사용하는 토큰의 정보가 해킹당하는 것</li>\n</ul>\n<p>정도가 있을 것 같았다.</p>\n<p>HTTP 요청을 하는 API 엔드포인트는 어쩔 수 없이 드러나야했다. 깃허브에는 API 요청시에 식별이 될 수 있을 만한 정보는 모두 <code>process.env</code>를 사용해서 환경변수로 돌려놔서 보이지는 않지만, 브라우저에서 요청을 보면 API 엔드포인트는 드러날 수 밖에 없었다. 그렇다면 API 자체적으로 막을 수 있는 방식이 필요했고, 여러가지 기본적인 예외처리를 하긴 했지만 웹서비스에서가 아닌 따로 요청을 해서 예상치 못한 요청을 받을 수 있을 것 같았다.</p>\n<p>알려지지 않은 key를 Header에 넣어서 API에서 미들웨어로 확인하고 요청을 받을 수도 있지만, 브라우저 요청을 보면 헤더가 드러나게 되어있어서 Key의 형태로는 할 수가 없었다. 서버리스 API라 세션을 사용할 수도 없고. 그렇다면 답은 토큰이었다. JWT를 사용해서 토큰을 생성하고 API의 최대 실행시간 이후에는 expire되게 만들어서 요청때 마다 다른 형태의 토큰을 보내게 했다. 물론 토큰을 해석할 수 도 있지만 굳이 이런 서비스의 토큰을 private key까지 해독해가며 침입하려고 하진 않을 것 같았다.</p>\n<p>토큰의 정보는 private key를 설정해서 최대한 드러나는 걸 막았다.</p>","frontmatter":{"title":"06__피스메인 홈페이지","summary":"피스메인 동아리 모집 페이지","time":"2021. 1. 31","platform":"WEB","link":"https://peacemain-club.github.io/","repository":"https://github.com/peacemain-club/peacemain-club.github.io"}}},"pageContext":{}},"staticQueryHashes":[]}