{"componentChunkName":"component---src-templates-devlog-js","path":"/devlog/essay/20210405","result":{"data":{"markdownRemark":{"html":"<p>Interview Preparaion Kit Dynamic Programming 문제</p>\n<p><strong>난이도</strong> Medium</p>\n<h2>문제</h2>\n<p>유치원에서 사탕을 나눠준다. 각 원생들에게는 점수가 있는데 옆에 있는 아이와 비교해서 점수가 높은 아이에게 점수가 낮은 아이보다 사탕을 많이 줘야한다. 줘야하는 사탕의 가능한 최소 갯수를 구하라.</p>\n<h2>예시</h2>\n<pre><code class=\"language-js\">arr = [4, 6, 4, 5, 6, 2]\n</code></pre>\n<p>순서대로 <code>1, 2, 1, 2, 3, 1</code> 만큼 주면 사탕을 최소한으로 줄 수 있다.  사탕의 총합은 10이다.</p>\n<h2>생각의 흐름</h2>\n<p>다이나믹 프로그래밍 문제인 만큼 메모이제이션 방법을 사용하기로 했다.</p>\n<p>어떻게 사용하냐면,</p>\n<ol>\n<li>가장 처음의 기준은 0으로 잡고 메모한다.</li>\n<li>다음 아이의 점수를 비교하보고 다음 아이의 점수가 크면 이전 메모 + 1을 하고, 커서를 해당 아이로 옮긴다.</li>\n<li>다음 아이의 점수가 작고 이전 메모가 양수일 때는 0을 메모하고, 음수일 때는 이전 메모 - 1을 한다.</li>\n<li>더 높은 점수의 아이가 나오면 음수가 된 메모들을 다 양수로 만들기 위해 내리막길을 걷던 점수의 길이와 가장 낮은 아이의 메모를 곱해서 더해준다.</li>\n</ol>\n<p>이렇게 사용을 하면 메모를 사용하고 하면 될 것 같았다.</p>\n<h3>1차 시기 코드</h3>\n<pre><code class=\"language-js\">function candies(n, arr) {\n    const memo = [0];\n    \n    let cursor = 0;\n    \n    for (let i = 1; i &#x3C; arr.length; i++) {\n        if (arr[i - 1] &#x3C; arr[i]) {\n            const temp = memo[i - 1];\n            \n            if (memo[i - 1] &#x3C; 0) {\n                const length = i - cursor;\n                memo[i - 1] = Math.abs(temp) * length;\n            }\n            \n            cursor = i;\n            memo[i] = temp + 1;\n        } else {\n            if (memo[i - 1] > 0) {\n                memo[i] = 0;\n            } else {\n                memo[i] = memo[i - 1] - 1;\n            }\n            \n            if (memo[i - 1] > 1) {\n                cursor = i;\n            }\n        }\n    }\n    \n    if (memo[arr.length - 1] &#x3C; 0) {\n        const length = arr.length - cursor;\n        memo[arr.length - 1] += Math.abs(memo[arr.length - 1]) * length;\n    }\n    \n    const answer = memo.reduce((acc, cur) => acc + cur, arr.length);\n    \n    return answer;\n}\n</code></pre>\n<p>결과는 실패. 어느정도 맞는 것도 있었지만 틀린 것도 있었다. 엣지 케이스가 있는 것 같다.</p>\n<p>엣지 케이스를 생각해봤는데, 어떤 경우인지 생각이 나지 않았다.</p>\n<p>그래서 다른 방법을 생각해보고, 인내심이 바닥나서 힌트를 얻기 위해 이미 해결한 사람들의 댓글을 봤는데,</p>\n<p>꼭 다이나믹 프로그래밍 방법을 사용하지 않고도 해결이 되는 문제였다.</p>\n<p>왼쪽에서 오른쪽으로 이동하며 큰 것이면 이전 사탕 + 1, 작은 것이면 다시 1을 넣는다.</p>\n<p>반대로 오른쪽에서 왼쪽으로 이동하면서도 똑같이 한다.</p>\n<p>이렇게 하고 나서 두 배열을 비교하며 더 큰 값을 넣으면 정답이 나오게 된다.</p>\n<h3>2차 시기 코드</h3>\n<pre><code class=\"language-js\">function candies(n, arr) {\n    const left_to_right = new Array(arr.length).fill(1);\n    const right_to_left = new Array(arr.length).fill(1);\n    \n    for (let i = 1; i &#x3C; arr.length; i++) {\n        if (arr[i - 1] &#x3C; arr[i]) {\n            left_to_right[i] = left_to_right[i - 1] + 1;\n        } else {\n            left_to_right[i] = 1;\n        }\n    }\n    \n    for (let i = arr.length - 2; i >= 0; i--) {\n        if (arr[i + 1] &#x3C; arr[i]) {\n            right_to_left[i] = right_to_left[i + 1] + 1;\n        } else {\n            right_to_left[i] = 1;\n        }\n    }\n    \n    const result = left_to_right.map((v, i) => {\n        return Math.max(v, right_to_left[i]);\n    });\n    \n    const answer = result.reduce((acc, cur) => acc + cur);\n    \n    return answer;\n}\n</code></pre>\n<p>결과는 성공이다. 이런 생각을 어떻게 했는지 신기하다. 1차시기 코드도 엣지 케이스가 뭔지 알면 해결해 볼텐데, 접근 자체는 틀린건 아닌거 같지만 생각하느라 인내심이 너무 바닥났다. 나중에 생각나면 수정해봐야 겠다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113501435-fa609f00-955f-11eb-8161-4e8fae641c94.png\" alt=\"image\"></p>","frontmatter":{"path":"devlog/essay/20210405","category":"coding test","title":"[해커랭크] Max Array Sum","summary":"오늘의 코딩테스트 21.4.5","date_created":"2021.4.5","date_updated":""}}},"pageContext":{}},"staticQueryHashes":[]}