{"componentChunkName":"component---src-templates-devlog-js","path":"/devlog/essay/20210404","result":{"data":{"markdownRemark":{"html":"<p>Interview Preparaion Kit Dynamic Programming 문제</p>\n<p><strong>난이도</strong> Medium</p>\n<h2>문제</h2>\n<p>주어진 배열에서 인접하지 않는 원소들 간의 부분배열의 합 중 가장 큰 값을 찾아라</p>\n<h2>예시</h2>\n<pre><code class=\"language-js\">arr = [-2, 1, 3, -4, 5]\n</code></pre>\n<p>인접하지 않는 원소들로 이루어진 부분집합은  <code>[-2, 3, 5]</code>, <code>[-2, 3]</code>, <code>[-2, -4]</code>, <code>[-2, 5]</code>, <code>[1, -4]</code>, <code>[1, 5]</code>, <code>[3, 5]</code> 이고 이 중 합이 가장 큰 건 <code>[3, 5]</code> 으로 답은 8이다.</p>\n<h2>생각의 흐름</h2>\n<p>다이나믹 프로그래밍 문제인 만큼 배열에서 메모이제이션 방법으로 해보면 좋을 것 같았다.</p>\n<p>반복문을 돌리면서 (바로 직전의 메모값)과 (현재의 값 + 직전 이전의 값)을 비교해서 더 큰걸 메모하는 방법으로 했다.</p>\n<h3>1차 시기 코드</h3>\n<pre><code class=\"language-js\">function maxSubsetSum(arr) {\n    const memo = new Array(arr.length).fill(0);\n    \n    arr.forEach((v, i) => {\n        if (i === 0) {\n            memo[0] = v;\n        } else if (i === 1) {\n            memo[1] = Math.max(memo[0], v);\n        } else {\n            const curr = v + memo[i - 2];\n            const prev = memo[i - 1];\n            \n            memo[i] = Math.max(curr, prev);\n        } \n    });\n    \n    return memo[arr.length - 1];\n}\n</code></pre>\n<p>결과는 실패. 어느정도 맞는 것도 있었지만 틀린 것도 있었다. 엣지 케이스나 문제의 조건을 제대로 적용하지 않았겠지.</p>\n<p>음수일 경우에도 처리르 해줘야 했다. 음수일 경우에는 아예 더하지 않는 방법을 선택했다. 어차피 문제는 최댓값을 구하는 것이기 때문에.</p>\n<p>그리고 코드도 좀 더 이해하기 쉽게 바꿨다. if 문이 너무 많으면 코드를 딱 봤을 때 이게 뭔지 잘 이해가 안되는 일이 있으니 최대한 변수의 이름을 이해하기 쉽고, 메소드를 사용해서 무슨 역할을 하는지 알기 쉽게 적어봤다.</p>\n<p>성능상에서는 조금 불리하겠지만, 조금의 성능 보다는 이해하기 쉬운 코드를 짜는게 더 좋은 것 같다. 코딩테스트때도 그럴까?</p>\n<h3>2차 시기 코드</h3>\n<pre><code class=\"language-js\">function maxSubsetSum(arr) {\n    const memo = new Array(arr.length).fill(0);\n    \n    memo[0] = Math.max(arr[0], 0);\n    memo[1] = Math.max(arr[0], arr[1], 0);\n    \n    for (let i = 2; i &#x3C; arr.length; i++) {\n        const value = Math.max(arr[i], 0);\n        \n        const curr = value + memo[i - 2];\n        const prev = memo[i - 1];\n            \n        memo[i] = Math.max(curr, prev);\n    }\n    \n    const answer = Math.max(memo[arr.length - 1], 0);\n    \n    return answer;\n}\n</code></pre>\n<p>결과는 성공이다. 위에 쓴 코드와 비교했을 때 더 이해하기 쉬워서 마음에 든다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113501435-fa609f00-955f-11eb-8161-4e8fae641c94.png\" alt=\"image\"></p>","frontmatter":{"path":"devlog/essay/20210404","category":"coding test","title":"[해커랭크] Max Array Sum","summary":"오늘의 코딩테스트 21.4.4","date_created":"2021.4.4","date_updated":""}}},"pageContext":{}},"staticQueryHashes":[]}