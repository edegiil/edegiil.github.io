{"componentChunkName":"component---src-templates-devlog-js","path":"/devlog/essay/20210331","result":{"data":{"markdownRemark":{"html":"<p>Interview Preparaion Kit String Manipulation 문제</p>\n<p><strong>난이도</strong> Medium</p>\n<h2>문제</h2>\n<p>특수한 문자열이 있다. 그 조건은</p>\n<ul>\n<li>모든 문자가 같은 경우 예) <code>aaaa</code></li>\n<li>가운데 글자를 제외하고 나머지 문자가 모두 같은 경우 예) <code>aaabaaa</code></li>\n</ul>\n<p>주어진 문자열의 서브스트링 중에서 위의 조건을 만족하는 서브스트링이 몇개 인지 찾아라.</p>\n<h2>예시</h2>\n<pre><code class=\"language-js\">a = 'asasd';\n</code></pre>\n<ul>\n<li>모든 문자가 같은 경우 : <code>a</code>, <code>s</code>, <code>a</code>, <code>s</code>, <code>d</code> </li>\n<li>가운데 글자를 제외하고 나머지 문자가 모두 같은 경우 : <code>asa</code>, <code>sas</code></li>\n</ul>\n<p>이렇게 총 7가지가 있다.</p>\n<h2>생각의 흐름</h2>\n<p>뒤집어도 같은 문자가 몇개 있는가. 이런 문제는 어디서 좀 흔하게 본적이 있는 느낌이 들었다. 그런게 있는지 일단 찾아봤다. 찾아보니 팰린드롬(회문)이라는 용어가 따로 있었다.</p>\n<p>모든 경우를 다 돌아가면서 찾기에는 너무 복잡해서 Dynamic Programming의 메모이제이션 방법을 사용해서 해결을 하는 방법이 있었다.</p>\n<p>그 방법은 <code>\"하나의 서브스트링이 있는데, 그 서브스트링의 양 끝이 같은 문자이고, 안에 있는 문자열이 역시 팰린드롬이라면, 그 서브스트링도 팰린드롬일 것이다\"</code> 라는 생각이었다.</p>\n<p>그걸 코드로 구현해서 해봤다.</p>\n<h3>1차 시기 코드</h3>\n<pre><code class=\"language-js\">function substrCount(n, s) {\n    const memo = new Array(n + 2).fill(0).map(() => new Array(n + 2).fill(0));\n    let count = 0;\n    \n    for (let i = 1; i &#x3C;= n; i++) {\n        memo[i][i] = 1;\n        count++;\n        \n        if (i !== n &#x26;&#x26; s[i - 1] === s[i]) {\n            memo[i][i + 1] = 1;\n            count++;\n        }\n    }\n    \n    for (let i = 1; i &#x3C;= n; i++) {\n        for (let j = i; j &#x3C;= n; j++) {\n            if (s[i - 1] === s[j - 1] &#x26;&#x26; memo[i + 1][j - 1] === 1) {\n                memo[i][j] = 1;\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113098379-5c08cc80-9233-11eb-8874-594bcdeeaf82.png\" alt=\"image\"></p>\n<p>결과는 뭔가 성공은 하는데, 다 빨간색이 되었다. 이런건 처음봤다. 뭔가 채점 서버에 오류가 있나 싶기도 했지만, 하나를 까서 보니 72만 자리의 문자열이었다. 72만 X 72만 이라면 대략 4900만 개가 되니까 그 만한 갯수의 배열을 만드는게 문제가 될 것 같았다.</p>\n<p>아니나 다를까 로컬에서 실행을 해보니 아래와 같이 메모리 문제가 나왔다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113098436-688d2500-9233-11eb-9453-0fadec1cdef5.png\" alt=\"image\"></p>\n<p>그럼 어떻게 해결해야 하나, 반복문 돌리면서 확인을 해야하나 싶었는데, 뭔가 문제가 이상했다. 왜 그냥 string again도 아니고, 앞에 special이 붙었을까?</p>\n<p>문제를 다시 읽어보니 모든 팰린드롬이 아니라 위에 두가지 조건을 만족하는 팰린드롬이 몇개인지 구하는 것이었다. 위에 두가지 조건이라 모든 서브스트링이 팰린드롬인지 확인 하지 않아도 되는 문제였다.</p>\n<p>영어라서 문제를 읽기가 싫은가 보다. 빨리 고쳐야 된다.</p>\n<p>방법은 스택을 사용해서 해보자 였다.</p>\n<p>평범하게 이중 반복문으로 문자열을 하나하나 비교해보며, 이게 위의 조건을 만족하는지 안하는지만 판별하면 된다고 생각했기에, 스택으로 하나씩 넣어가며 아래와 같이 생각해보기로 했다.</p>\n<ol>\n<li>가장 앞에 글자를 하나의 플래그로 잡고, 다음에 들어오는 문자가 플래그와 같으면 결과값을 하나 증가시킨다.(모두 같은 문자 조건)</li>\n<li>다른 문자가 오면 그 문자로 플래그를 바꾸고, 이후부터는 가장 첫번째 문자열과 같은 경우에 갯수를 세어서 왼쪽에 있던 같은 문자들의 갯수와 같아지면 결과값을 증가시키고 안쪽 반복문을 break 시킨다.(중간을 제외한 나머지가 같은 문자 조건)</li>\n</ol>\n<p>2번처럼 하나라도 나오면 break 시켜도 되는게, 어차피 다음 반복문으로 넘어가면서 다 체크를 하기 때문에 중간을 제외한 나머지가 같은 문자 조건은 제일 처음 문자부터, 한번만 만족해도 끝나면 된다.</p>\n<pre><code class=\"language-js\">function substrCount(n, s) {\n    let count = n;\n    \n    for (let i = 0; i &#x3C; n - 1; i++) {\n        let flag = s[i];\n        let left_side_count = 1;\n        let right_side_count = 0;\n        \n        for (let j = i + 1; j &#x3C; n; j++) {\n            if (flag !== s[i] &#x26;&#x26; flag === s[j]) {\n                break;\n            }\n            \n            if (flag === s[j]) {\n                if (flag === s[i]) {\n                    left_side_count++;\n                    count++;\n                }\n            } else {\n                if (flag === s[i]) {\n                    flag = s[j];\n                } else {\n                    if (s[j] === s[i]) {\n                        right_side_count++;\n                    } else {\n                        break;\n                    }\n                    \n                    if (left_side_count === right_side_count) {\n                        count++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113106492-cb83b980-923d-11eb-9aa4-9e671d5340ec.png\" alt=\"image\"></p>\n<p>결과는 성공이었다. <code>if</code>문이 너무 많은게 좀 마음에 들지 않지만 일단은 돌아간다.</p>\n<p>문제를 좀 잘 읽어야겠다.</p>","frontmatter":{"path":"devlog/essay/20210331","category":"coding test","title":"[해커랭크] Special String Again","summary":"오늘의 코딩테스트 21.3.31","date_created":"2021.3.31","date_updated":""}}},"pageContext":{}},"staticQueryHashes":[]}