{"componentChunkName":"component---src-templates-devlog-js","path":"/devlog/essay/20210401","result":{"data":{"markdownRemark":{"html":"<p>Interview Preparaion Kit String Manipulation 문제</p>\n<p><strong>난이도</strong> Medium</p>\n<h2>문제</h2>\n<p>두개의 문자열 중에 겹치는 서브스트링 중 가장 긴 것의 길이가 얼마인지 구하기</p>\n<h2>예시</h2>\n<pre><code class=\"language-js\">s1 = 'ABCD';\ns2 = 'ABDC';\n</code></pre>\n<p>겹치는 서브스트링은 <code>ABC</code>, <code>ABD</code>로 길이가 3이다.</p>\n<h2>생각의 흐름</h2>\n<p>둘 중 하나의 문자열을 기준으로 하나씩 반복문을 돌린다. 같은 문자를 만날경우 커서를 만난 쪽으로 옮겨서 그 이후부터 다시 시작하는 방식으로 하면 좋을 것 같다고 생각했다.</p>\n<p>예를 들어, <code>ABCD</code>와 <code>ABDC</code>일 경우에는,</p>\n<ol>\n<li><code>A</code>와 <code>A</code> => 같음 커서는 <code>A</code> 다음으로</li>\n<li><code>B</code>와 <code>B</code> => 같음 커서는 <code>B</code> 다음으로</li>\n<li><code>C</code>와 <code>D</code> => 다름</li>\n<li><code>C</code>와 <code>C</code> => 같음 커서는 <code>C</code> 다음으로. <code>C</code> 다음은 없으므로 종료.</li>\n</ol>\n<p>그런데 이렇게 하면 문제점이 있었다.</p>\n<p>예를 들어, <code>SHINCHAN</code>과 <code>NOHARAA</code>의 경우에는</p>\n<p>위의 방법대로 앞에서 부터 비교하면, 나오는 결과는 <code>HA</code>로 길이가 2이다. 하지만 답은 <code>NHA</code>로 3이다.</p>\n<p>뭐가 문제일지 생각해보니, 처음부터 해서 나오는 값이 꼭 제일 길다는 보장이 없었다.</p>\n<h3>1차 시기 코드</h3>\n<pre><code class=\"language-js\">function commonChild(s1, s2) {\n    let count = 0;\n    let cursor = 0;\n    \n    for (let i = 0; i &#x3C; s1.length; i++) {\n        const target = s1[i];\n        \n        for (let j = cursor; j &#x3C; s2.length; j++) {\n            if (target === s2[j]) {\n                cursor = j + 1;\n                count++;\n                break;\n            }\n        }\n    }\n    \n    return count;\n}\n</code></pre>\n<p>어떻게 하면 될까 생각하다가 옛날에 학교에서 알고리즘 수업을 듣다가 비슷한 종류에 대해서 배웠던 기억이 났다. 최장 공통 부분수열(LCS)이라는 게 있었다.</p>\n<p>기본적인 개념은 앞에서부터 나올 수 있는 모든 부분수열에서의 공통 부분의 갯수를 구해서 그 중에서 최장을 찾는 방식이다. 표로 만들어서 손으로는 만들기는 쉽지만 이제 이걸 코드로 만드는 게 문제다.</p>\n<h3>2차 시기 코드</h3>\n<pre><code class=\"language-js\">function commonChild(s1, s2) {\n    const array = new Array(s1.length + 1).fill(0).map(() => new Array(s2.length + 1).fill(0));\n    let maximum = 0;\n    \n    for (let i = 0; i &#x3C; s1.length; i++) {\n        for (let j = 0; j &#x3C; s2.length; j++) {\n            if (s1[i] === s2[j]) {\n                array[i + 1][j + 1] = array[i][j] + 1;\n            } else {\n                array[i + 1][j + 1] = Math.max(array[i][j + 1], array[i + 1][j]);\n            }\n            \n            if (array[i + 1][j + 1] > maximum) {\n                maximum = array[i + 1][j + 1];\n            }\n        }\n    }\n    \n    return maximum;\n}\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113253951-ed924000-9300-11eb-92e3-6e8e153030da.png\" alt=\"image\"></p>\n<p>결과는 성공이었다. 학교 수업시간에 들은 기억이 날 정도면 아주 기본적인 내용인 것 같은데, 역시 여러 알고리즘에 대해서 알고 있어야 하나 싶다. 기본이 쌓이는 건 좋지만 기본을 위해 기본을 공부하기 보다는 일단은 현실적으로 문제를 풀면서 나오는 이론이나 알고리즘을 따로 공부하는 방식으로 기본을 쌓도록 해야겠다.</p>","frontmatter":{"path":"devlog/essay/20210401","category":"coding test","title":"[해커랭크] Common Child","summary":"오늘의 코딩테스트 21.4.1","date_created":"2021.4.1","date_updated":""}}},"pageContext":{}},"staticQueryHashes":[]}