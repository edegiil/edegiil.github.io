{"componentChunkName":"component---src-templates-devlog-js","path":"/devlog/essay/20210402","result":{"data":{"markdownRemark":{"html":"<p>Interview Preparaion Kit Search 문제</p>\n<p><strong>난이도</strong> Medium</p>\n<h2>문제</h2>\n<p>공장의 기계는 각각 물건 한 개를 생산하는데 걸리는 시간이 다르다. 이 기계를 모두 사용해서 원하는 양을 생산하기 위해서 걸리는 가장 짧은 시간은 얼마인가?</p>\n<h2>예시</h2>\n<pre><code class=\"language-js\">goal = 5;\nmachines = [2, 3];\n</code></pre>\n<p>5개를 만들기 위해서는 총 6초가 필요하다. 2초에 하나를 만드는 기계는 3개를 생산하고, 3초에 하나 만드는 기계는 2개를 생산한다. 이게 가장 짧은 시간이다.</p>\n<p>(7초일때도 똑같이 5개를 만들지만 6초보다 길다.)</p>\n<h2>생각의 흐름</h2>\n<p>그냥 시뮬레이션 돌리듯이 하면 안되나? 라는 생각이 가장 먼저 들었다.</p>\n<p>기계마다 하나의 객체를 만들어서 original 시간과 현재 하나를 만들기 까지 남은 시간을 넣어서 초마다 하나씩 빼주는 방식으로 하면 어떨까 생각했다.</p>\n<h3>1차 시기 코드</h3>\n<pre><code class=\"language-js\">function minTime(machines, goal) {\n    let products = 0;\n    let time = 0;\n    \n    const machine_queue = machines.map((time) => {\n        return {\n            original_time: time,\n            time_left: time,\n        }\n    })\n    \n    while (products &#x3C; goal) {\n        time++;\n        \n        machine_queue.forEach((a) => {\n            a.time_left--;\n            \n            if (a.time_left === 0) {\n                a.time_left = a.original_time;\n                products++;\n            }\n        });\n    }\n\n    return time;\n}\n</code></pre>\n<p>코드도 짧고 뭔가 괜찮아 보였다.</p>\n<p>결과는</p>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113398050-f1919100-93d8-11eb-8598-6e01e1103ca3.png\" alt=\"image\"></p>\n<p>답 자체는 맞지만 몇개에서 타임아웃이 걸렸다.</p>\n<p>하나를 까서 보니, 정답이 304844592이었다. 결국 3억 번의 배열을 돌려야 하는데, 당연히 타임아웃이 나지.</p>\n<p>그럼 다른 방법이 뭐가 있을까? 생각하다가 예전에 프로그래머스에서 풀었던 문제 중에 비슷한게 있었던게 기억났다.</p>\n<p>이진 탐색을 사용하는 문제였는데, 이 문제의 분야가 탐색이었으니 그게 맞는 방법이리라.</p>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113420746-cb81e600-9404-11eb-87bb-af9cf43fec49.png\" alt=\"Frame 1\"></p>\n<p>개념은 이렇다. 최소 범위와 최대 범위를 설정하고(여기서는 최소 시간과 최대 시간), 중간값(여기서는 최소 시간 + 최대 시간 / 2)을 가지고 기계가 몇개를 생산할 수 있는지 구해본다.</p>\n<p>그렇게 구한 기계의 생산성이 목표치 보다 크거나 같다면 중간값을 최대 범위로 두고 또 계산하는 식으로 이렇게 계속 한다.</p>\n<p>그러다 보면 더 이상 움직일 수 없는 값이 오게 되는데 그게 바로 정답이 되는 것이다.</p>\n<h3>2차 시기 코드</h3>\n<pre><code class=\"language-js\">function minTime(machines, goal) {\n    let result = 0;\n    const slowest_machine = Math.max(...machines);\n    const fastest_machine = Math.min(...machines);\n    \n    const time_max = goal * slowest_machine;\n    const time_min = Math.floor(goal / machines.length) * fastest_machine;\n    \n    let left = time_min;\n    let right = time_max;\n    \n    while (left &#x3C;= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        const productivity = machines.reduce((acc, cur) => {\n           return acc + Math.floor(mid / cur);\n        }, 0);\n    \n        if (productivity >= goal) {\n            right = mid - 1;\n            result = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return result;\n}\n</code></pre>\n<p>결과는 성공이다. 마지막에 몇 십분 동안 답이 안나와서 고민했는데 알고보니 결과값이 <code>producticity</code>가 아니라 <code>mid</code>값으로 해야했다. </p>\n<p>집중하자</p>\n<p><img src=\"https://user-images.githubusercontent.com/35324795/113419554-a3918300-9402-11eb-82a6-ce2a0f492b48.png\" alt=\"image\"></p>","frontmatter":{"path":"devlog/essay/20210402","category":"coding test","title":"[해커랭크] Minimum Time Required","summary":"오늘의 코딩테스트 21.4.2","date_created":"2021.4.2","date_updated":""}}},"pageContext":{}},"staticQueryHashes":[]}